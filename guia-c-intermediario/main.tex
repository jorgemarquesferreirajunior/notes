\documentclass[12pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[portuguese]{babel}
\usepackage{geometry}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Manual Avançado: Ponteiros, Alocação Dinâmica e Structs com aplicação em MLP},
}
\usepackage{listings}
\usepackage{xcolor}

% Definição de estilo para código C
\lstdefinestyle{cstyle}{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green!50!black},
    morecomment=[l][\color{magenta}]{\#},
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    literate=
        {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
        {ã}{{\~a}}1 {õ}{{\~o}}1 {ç}{{\c{c}}}1 {À}{{\`A}}1 {É}{{\'E}}1
        {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1 {Ã}{{\~A}}1 {Õ}{{\~O}}1 {Ç}{{\c{C}}}1,
}

\lstset{style=cstyle}

\title{\Huge \textbf{Manual Avançado de C} \\[0.5cm]
\Large Ponteiros, Alocação Dinâmica e Structs \\[0.3cm]
\bfseries Aplicação: Uma MLP para classificação MNIST}
\author{Seu Nome}
\date{\today}

\begin{document}

\frontmatter
\maketitle
\tableofcontents

\mainmatter

% ============================================
\chapter{Ponteiros em C}
\section{Conceitos Fundamentais}
Um ponteiro é uma variável que armazena o endereço de memória de outra variável. Em C, eles são essenciais para manipulação direta da memória, passagem eficiente de parâmetros e implementação de estruturas de dados dinâmicas.

\subsection{Declaração e Operadores Básicos}
\begin{lstlisting}
int x = 10;
int *p;       // declara um ponteiro para inteiro
p = &x;       // p recebe o endereco de x
printf("%d\n", *p); // acessa o valor apontado (de referência)
\end{lstlisting}
Operadores:
\begin{itemize}
    \item \texttt{\&} : operador endereço (referência)
    \item \texttt{*} : operador de referência (acesso ao valor apontado)
\end{itemize}

\subsection{Aritmética de Ponteiros}
Ao incrementar um ponteiro, ele avança pelo tamanho do tipo apontado.
\begin{lstlisting}
int arr[5] = {10,20,30,40,50};
int *ptr = arr; // ptr aponta para arr[0]
ptr++;          // agora aponta para arr[1]
printf("%d\n", *ptr); // 20
\end{lstlisting}
Isso permite percorrer arrays de forma eficiente.

\subsection{Ponteiros e Arrays}
O nome de um array é um ponteiro constante para o primeiro elemento.
\begin{lstlisting}
int vet[3] = {1,2,3};
int *p = vet;   // equivalente a int *p = &vet[0];
vet[1] == *(p+1); // verdadeiro
\end{lstlisting}

\subsection{Ponteiros para Ponteiros — Uso Real}

Ponteiros para ponteiros são essenciais quando precisamos modificar o endereço
de um ponteiro dentro de uma função (ex.: alocação dinâmica) ou construir
estruturas como matrizes dinâmicas.

\subsubsection{Exemplo 1 — Alocação dinâmica dentro da função}

\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

void alloc_vector(int **v, size_t n) {
    *v = malloc(n * sizeof(int));
    if (*v == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    for (size_t i = 0; i < n; i++)
        (*v)[i] = i * 10;
}

int main() {
    int *vec = NULL;

    alloc_vector(&vec, 5);

    for (int i = 0; i < 5; i++)
        printf("%d ", vec[i]);

    free(vec);
    return 0;
}
\end{lstlisting}

\textbf{O que aconteceu:}

\begin{itemize}
\item Passamos o endereço do ponteiro: \texttt{\&vec}
\item A função modifica o ponteiro original
\item Memória foi alocada na \textbf{heap}
\item Evitamos segmentation fault verificando \texttt{malloc}
\end{itemize}

% ======================================================

\subsubsection{Exemplo 2 — Matriz dinâmica usando ponteiro para ponteiro}

\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

void matrix_alloc(int ***M, size_t rows, size_t cols) {
    *M = malloc(rows * sizeof(int*));
    if (*M == NULL) exit(EXIT_FAILURE);

    for (size_t i = 0; i < rows; i++) {
        (*M)[i] = malloc(cols * sizeof(int));
        if ((*M)[i] == NULL) exit(EXIT_FAILURE);
    }
}

void matrix_free(int **M, size_t rows) {
    for (size_t i = 0; i < rows; i++)
        free(M[i]);
    free(M);
}

int main() {
    int **A = NULL;

    matrix_alloc(&A, 3, 3);

    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            A[i][j] = i + j;

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++)
            printf("%d ", A[i][j]);
        printf("\n");
    }

    matrix_free(A, 3);
    return 0;
}
\end{lstlisting}

\textbf{Pontos de engenharia:}

\begin{itemize}
\item \texttt{int ***M} permite modificar a matriz original
\item Cada linha é alocada separadamente
\item Liberação correta evita \textit{memory leak}
\item Estrutura equivalente a uma matriz dinâmica real
\end{itemize}

\subsection{Ponteiros para Funções}
Permitem que funções sejam passadas como argumentos.
\begin{lstlisting}
int soma(int a, int b) { return a+b; }
int (*op)(int,int);   // ponteiro para funcao que recebe dois ints e retorna int
op = &soma;
int resultado = op(3,4); // 7
\end{lstlisting}
São úteis para callbacks e algoritmos genéricos (ex: \texttt{qsort}).

% ============================================
\chapter{Alocação Dinâmica de Memória}
\section{Stack vs Heap}
\label{sec:stackvshep}
\begin{itemize}
    \item \textbf{Stack}: memória automática, gerenciada pelo compilador. Variáveis locais, parâmetros de função. Alocação e liberação rápidas, mas tamanho limitado (pode causar stack overflow).
    \item \textbf{Heap}: memória dinâmica, controlada pelo programador. Alocada com \texttt{malloc}/\texttt{calloc}/\texttt{realloc} e liberada com \texttt{free}. Maior flexibilidade, porém mais lenta e sujeita a vazamentos.
\end{itemize}
\subsection*{Organização da memória de um processo}
\begin{itemize}
    \item \textbf{Text}: código executável (somente leitura).
    \item \textbf{Data}: variáveis globais/estáticas inicializadas.
    \item \textbf{BSS}: variáveis globais/estáticas não inicializadas (zeradas).
    \item \textbf{Heap}: cresce para cima (endereços crescentes).
    \item \textbf{Stack}: cresce para baixo (endereços decrescentes).
\end{itemize}

\section{Funções de Alocação}
Todas estão em \texttt{<stdlib.h>}.

\subsection{malloc}
\begin{lstlisting}
void *malloc(size_t size);
\end{lstlisting}
Aloca um bloco de \texttt{size} bytes na heap. Retorna ponteiro para o início do bloco ou \texttt{NULL} se falhar. O conteúdo não é inicializado.

\subsection{calloc}
\begin{lstlisting}
void *calloc(size_t nmemb, size_t size);
\end{lstlisting}
Aloca espaço para um array de \texttt{nmemb} elementos de \texttt{size} bytes cada. Inicializa todos os bytes com zero.

\subsection{realloc}
\begin{lstlisting}
void *realloc(void *ptr, size_t new_size);
\end{lstlisting}
Redimensiona o bloco apontado por \texttt{ptr} para \texttt{new_size} bytes. Pode mover o bloco se necessário. Retorna novo ponteiro.

\subsection{free}
\begin{lstlisting}
void free(void *ptr);
\end{lstlisting}
Libera o bloco de memória previamente alocado. Após \texttt{free}, o ponteiro se torna inválido (deve ser atribuído a \texttt{NULL} para evitar uso acidental).

\subsection{Exemplo Completo}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *vetor;
    int n = 10;
    vetor = (int*) malloc(n * sizeof(int));
    if (vetor == NULL) {
        fprintf(stderr, "Erro de alocacao\n");
        return 1;
    }
    for (int i = 0; i < n; i++)
        vetor[i] = i * i;
    // redimensiona para 20 elementos
    int *temp = (int*) realloc(vetor, 20 * sizeof(int));
    if (temp == NULL) {
        free(vetor);
        return 1;
    }
    vetor = temp;
    // ...
    free(vetor);
    return 0;
}
\end{lstlisting}

\section{Erros Comuns e Boas Práticas}
\begin{itemize}
    \item Não verificar o retorno de \texttt{malloc}/\texttt{calloc}.
    \item Esquecer de liberar memória (\textit{memory leak}).
    \item Acessar memória já liberada (\textit{use-after-free}).
    \item Liberar o mesmo ponteiro duas vezes (\textit{double free}).
    \item Escrever além dos limites do bloco alocado (\textit{buffer overflow}).
    \item Usar \texttt{free} em ponteiros que não vieram de alocação dinâmica.
\end{itemize}
Boas práticas:
\begin{itemize}
    \item Sempre inicialize ponteiros com \texttt{NULL}.
    \item Após \texttt{free}, atribua \texttt{NULL} ao ponteiro.
    \item Use \texttt{sizeof} para calcular o tamanho correto.
    \item Prefira \texttt{calloc} se precisar de zeros.
    \item Utilize ferramentas como \texttt{valgrind} para detectar vazamentos.
\end{itemize}

% ============================================
\chapter{Structs e Unions}
\section{Definindo Structs}
Struct é uma coleção de variáveis (membros) agrupadas sob um mesmo nome.
\begin{lstlisting}
struct Ponto {
    int x;
    int y;
};
\end{lstlisting}
Para declarar variáveis:
\begin{lstlisting}
struct Ponto p1;
p1.x = 10;
p1.y = 20;
\end{lstlisting}

\section{typedef}
Facilita a declaração:
\begin{lstlisting}
typedef struct {
    int x;
    int y;
} Ponto;
Ponto p2;
\end{lstlisting}

\section{Ponteiros para Struct}
Acesso aos membros via seta (\texttt{->}).
\begin{lstlisting}
Ponto *ptr = &p2;
ptr->x = 30;  // equivalente a (*ptr).x = 30;
\end{lstlisting}

\section{Alinhamento e Padding}
O compilador pode inserir bytes de preenchimento entre os membros para garantir alinhamento em endereços múltiplos do tamanho da palavra da máquina. Isso afeta o tamanho total da struct.
\begin{lstlisting}
struct Exemplo {
    char c;      // 1 byte
    int i;       // 4 bytes (geralmente alinhado a 4)
}; // sizeof pode ser 8 (3 bytes de padding)
\end{lstlisting}
Para evitar padding, pode-se usar \texttt{\#pragma pack} (não portável) ou reordenar membros.

\section{Unions}
Uma union permite armazenar diferentes tipos no mesmo espaço de memória. O tamanho é o do maior membro.
\begin{lstlisting}
union Valor {
    int i;
    float f;
    char str[20];
};
\end{lstlisting}
Útil para economizar memória quando apenas um dos campos é usado por vez.

% ============================================
\chapter{Aplicação Prática: MLP para MNIST em C}
Neste capítulo, desenvolveremos um framework simples de rede neural MLP (Multi-Layer Perceptron) para classificar dígitos manuscritos do dataset MNIST. O foco será no uso correto de ponteiros, alocação dinâmica e structs.

\section{Visão Geral do MNIST}
O MNIST contém 70.000 imagens 28x28 em escala de cinza (0–255), divididas em 60.000 treino e 10.000 teste. Cada imagem representa um dígito de 0 a 9.

\section{Estruturas de Dados}
Definiremos structs para representar matrizes, camadas e a rede.

\subsection{Matriz}
\begin{lstlisting}
typedef struct {
    int linhas;
    int colunas;
    float **dados;  // ponteiro para ponteiro (linhas)
} Matriz;
\end{lstlisting}

Funções básicas:
\begin{lstlisting}
Matriz* matriz_criar(int lin, int col) {
    Matriz *m = (Matriz*) malloc(sizeof(Matriz));
    m->linhas = lin;
    m->colunas = col;
    m->dados = (float**) malloc(lin * sizeof(float*));
    for (int i = 0; i < lin; i++) {
        m->dados[i] = (float*) malloc(col * sizeof(float));
        // inicializar com zeros
        for (int j = 0; j < col; j++)
            m->dados[i][j] = 0.0f;
    }
    return m;
}

void matriz_destruir(Matriz *m) {
    if (!m) return;
    for (int i = 0; i < m->linhas; i++)
        free(m->dados[i]);
    free(m->dados);
    free(m);
}
\end{lstlisting}

\subsection{Camada}
Cada camada possui pesos, biases, e armazena a entrada/saída para retropropagação.
\begin{lstlisting}
typedef enum { SIGMOID, RELU, SOFTMAX } Ativacao;

typedef struct {
    int entrada_size;
    int saida_size;
    Matriz *pesos;      // [saida_size x entrada_size]
    Matriz *bias;       // [saida_size x 1]
    Matriz *entrada;    // guarda para backprop
    Matriz *saida;      // saida apos ativacao
    Ativacao ativ;
} Camada;
\end{lstlisting}

Criação:
\begin{lstlisting}
Camada* camada_criar(int in, int out, Ativacao at) {
    Camada *cam = (Camada*) malloc(sizeof(Camada));
    cam->entrada_size = in;
    cam->saida_size = out;
    cam->pesos = matriz_criar(out, in);
    cam->bias = matriz_criar(out, 1);
    cam->entrada = NULL;
    cam->saida = NULL;
    cam->ativ = at;
    // inicializar pesos aleatoriamente (pequenos)
    for (int i = 0; i < out; i++) {
        for (int j = 0; j < in; j++) {
            cam->pesos->dados[i][j] = ((float)rand() / RAND_MAX - 0.5f) * 0.1f;
        }
        cam->bias->dados[i][0] = 0.0f;
    }
    return cam;
}

void camada_destruir(Camada *cam) {
    if (!cam) return;
    matriz_destruir(cam->pesos);
    matriz_destruir(cam->bias);
    if (cam->entrada) matriz_destruir(cam->entrada);
    if (cam->saida) matriz_destruir(cam->saida);
    free(cam);
}
\end{lstlisting}

\subsection{Rede}
A rede é uma lista (array dinâmico) de camadas.
\begin{lstlisting}
typedef struct {
    int num_camadas;
    Camada **camadas;  // array de ponteiros para Camada
} MLP;
\end{lstlisting}

Criação e destruição:
\begin{lstlisting}
MLP* mlp_criar(int num_camadas, int *tamanhos, Ativacao *ativacoes) {
    MLP *rede = (MLP*) malloc(sizeof(MLP));
    rede->num_camadas = num_camadas;
    rede->camadas = (Camada**) malloc(num_camadas * sizeof(Camada*));
    for (int i = 0; i < num_camadas; i++) {
        int in = (i == 0) ? tamanhos[0] : tamanhos[i]; // na verdade, tamanhos[i] eh saida da camada i? Precisamos: entrada = tamanho anterior
        int out = tamanhos[i+1];
        // Corrigindo: tamanhos[0] = entrada, tamanhos[1] = saida cam1, ...
        // Vamos adotar: tamanhos[0] = entrada, tamanhos[1] = saida primeira camada, etc.
        // num_camadas = numero de camadas, entao tamanhos tem num_camadas+1 elementos.
    }
    return rede;
}
\end{lstlisting}

Para simplificar, faremos uma função que recebe array de tamanhos (incluindo entrada e saída de cada camada).

\section{Operações com Matrizes}
Implementaremos funções essenciais:
\begin{itemize}
    \item \texttt{matriz\_multiplicar(A, B)}: retorna nova matriz A*B.
    \item \texttt{matriz\_somar(A, B)}: soma elemento a elemento (in-place ou nova).
    \item \texttt{matriz\_aplicar\_ativacao(M, tipo)}: aplica função de ativação em cada elemento.
    \item \texttt{matriz\_softmax(M)}: aplica softmax (para classificação).
\end{itemize}

Exemplo de multiplicação:
\begin{lstlisting}
Matriz* matriz_multiplicar(Matriz *A, Matriz *B) {
    if (A->colunas != B->linhas) return NULL;
    Matriz *C = matriz_criar(A->linhas, B->colunas);
    for (int i = 0; i < A->linhas; i++) {
        for (int j = 0; j < B->colunas; j++) {
            float soma = 0.0f;
            for (int k = 0; k < A->colunas; k++) {
                soma += A->dados[i][k] * B->dados[k][j];
            }
            C->dados[i][j] = soma;
        }
    }
    return C;
}
\end{lstlisting}

\section{Forward Propagation}
Dada uma entrada (matriz coluna), propaga pela rede.
\begin{lstlisting}
Matriz* mlp_forward(MLP *rede, Matriz *entrada) {
    Matriz *atual = entrada;
    for (int i = 0; i < rede->num_camadas; i++) {
        Camada *cam = rede->camadas[i];
        // guarda entrada para backprop
        cam->entrada = matriz_copiar(atual); // precisamos de matriz_copiar
        // z = pesos * entrada + bias
        Matriz *z = matriz_multiplicar(cam->pesos, atual);
        // somar bias (broadcast) - faremos funcao especifica
        matriz_soma_bias(z, cam->bias);
        // aplicar ativacao
        if (cam->ativ == SOFTMAX) {
            matriz_softmax(z);
        } else {
            matriz_aplicar_ativacao(z, cam->ativ);
        }
        // se nao for a primeira iteracao, liberar saida anterior
        if (cam->saida) matriz_destruir(cam->saida);
        cam->saida = z;
        atual = z;
    }
    return atual; // saida da ultima camada
}
\end{lstlisting}

\section{Backpropagation e Treinamento}
Devido à complexidade, implementaremos uma versão simplificada com gradiente descendente. Para uma MLP, precisamos calcular o gradiente para cada camada e atualizar pesos. Vamos assumir uso de entropia cruzada e softmax na saída.

Devido à extensão, apresentaremos apenas o esqueleto e as funções de atualização.

\section{Leitura do Dataset MNIST}
O formato MNIST (IDX) é simples: arquivos contêm cabeçalho de 16 bytes e depois os dados. Implementaremos funções para ler imagens e rótulos.

Exemplo de leitura de imagens:
\begin{lstlisting}
unsigned char* ler_imagens(const char *filename, int *n_imagens) {
    FILE *fp = fopen(filename, "rb");
    if (!fp) return NULL;
    int magic, n, rows, cols;
    fread(&magic, 4, 1, fp); magic = __builtin_bswap32(magic); // big-endian
    fread(&n, 4, 1, fp); n = __builtin_bswap32(n);
    fread(&rows, 4, 1, fp); rows = __builtin_bswap32(rows);
    fread(&cols, 4, 1, fp); cols = __builtin_bswap32(cols);
    *n_imagens = n;
    unsigned char *data = (unsigned char*) malloc(n * rows * cols);
    fread(data, 1, n * rows * cols, fp);
    fclose(fp);
    return data;
}
\end{lstlisting}
Normalizamos os pixels para [0,1] convertendo para float.

\section{Exemplo Completo de Uso}
Abaixo, um trecho que cria uma rede com uma camada oculta de 128 neurônios e camada de saída softmax com 10 neurônios, treina por algumas épocas e avalia.

\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

// ... (todas as definicoes anteriores)

int main() {
    srand(time(NULL));
    // carregar dados MNIST (supondo arquivos na pasta)
    int n_train;
    unsigned char *img_train = ler_imagens("train-images.idx3-ubyte", &n_train);
    unsigned char *lbl_train = ler_rotulos("train-labels.idx1-ubyte", &n_train);
    // converter para matrizes de entrada (float)
    // cada imagem 28*28 = 784
    int entrada_size = 784;
    int saida_size = 10;
    int camadas_tamanhos[] = {entrada_size, 128, saida_size};
    Ativacao ativacoes[] = {RELU, SOFTMAX};
    MLP *rede = mlp_criar(2, camadas_tamanhos, ativacoes); // 2 camadas
    // loop de treinamento (simplificado)
    for (int epoch = 0; epoch < 5; epoch++) {
        float loss = 0.0f;
        for (int i = 0; i < n_train; i++) {
            // preparar entrada: matriz coluna 784x1
            Matriz *entrada = matriz_criar(entrada_size, 1);
            for (int j = 0; j < entrada_size; j++) {
                entrada->dados[j][0] = img_train[i*entrada_size + j] / 255.0f;
            }
            // target: one-hot
            Matriz *target = matriz_criar(saida_size, 1);
            target->dados[lbl_train[i]][0] = 1.0f;
            
            // forward
            Matriz *saida = mlp_forward(rede, entrada);
            
            // calcular perda (cross-entropy) e gradientes (backward)
            // ... (implementar backprop)
            
            // atualizar pesos (gradient descent)
            // ...
            
            matriz_destruir(entrada);
            matriz_destruir(target);
        }
        printf("Epoca %d concluida\n", epoch);
    }
    // avaliar no teste...
    // liberar memoria
    mlp_destruir(rede);
    free(img_train);
    free(lbl_train);
    return 0;
}
\end{lstlisting}

\section{Observações sobre o Código}
- O código acima é um esqueleto; a implementação completa exigiria funções detalhadas de backprop e atualização.
- É fundamental gerenciar corretamente a memória: cada \texttt{matriz\_criar} deve ter seu \texttt{matriz\_destruir} correspondente.
- O uso de ponteiros duplos para matrizes permite indexação conveniente, mas pode ser menos eficiente que uma única alocação contígua. Para desempenho, poderíamos armazenar todos os dados em um vetor linear e acessar via índice.
- O projeto serve como excelente exercício para consolidar ponteiros, alocação dinâmica e structs.

% ============================================
\chapter{Conclusão e Boas Práticas}
Ao longo deste manual, exploramos os conceitos fundamentais de ponteiros, alocação dinâmica e structs em C, culminando em um projeto prático de rede neural. Lembre-se sempre:
\begin{itemize}
    \item Inicialize ponteiros.
    \item Verifique falhas de alocação.
    \item Libere memória alocada dinamicamente.
    \item Use ferramentas de depuração (valgrind, gdb).
    \item Documente seu código, especialmente quando há manipulação complexa de memória.
\end{itemize}
Dominar esses tópicos é essencial para se tornar um programador C eficiente e para entender o funcionamento interno de sistemas e bibliotecas.

\appendix
\chapter{Funções Auxiliares (Exemplos)}
\begin{lstlisting}
// copiar matriz
Matriz* matriz_copiar(Matriz *origem) {
    Matriz *copia = matriz_criar(origem->linhas, origem->colunas);
    for (int i = 0; i < origem->linhas; i++)
        for (int j = 0; j < origem->colunas; j++)
            copia->dados[i][j] = origem->dados[i][j];
    return copia;
}

// somar bias (vetor coluna) a cada coluna da matriz? Para MLP, bias é somado a cada exemplo.
// Como entrada é coluna, apenas somar elemento a elemento.
void matriz_soma_bias(Matriz *m, Matriz *bias) {
    if (m->linhas != bias->linhas || bias->colunas != 1) return;
    for (int i = 0; i < m->linhas; i++)
        for (int j = 0; j < m->colunas; j++)
            m->dados[i][j] += bias->dados[i][0];
}
\end{lstlisting}

\end{document}